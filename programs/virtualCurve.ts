/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedClaimProtocolFeeInstruction,
  type ParsedClaimTradingFeeInstruction,
  type ParsedCloseClaimFeeOperatorInstruction,
  type ParsedCreateClaimFeeOperatorInstruction,
  type ParsedCreateConfigInstruction,
  type ParsedInitializeVirtualPoolWithSplTokenInstruction,
  type ParsedInitializeVirtualPoolWithToken2022Instruction,
  type ParsedMigrateMeteoraDammInstruction,
  type ParsedMigrateMeteoraDammLockLpTokenForCreatorInstruction,
  type ParsedMigrateMeteoraDammLockLpTokenForPartnerInstruction,
  type ParsedMigrationMeteoraDammCreateMetadataInstruction,
  type ParsedPartnerWithdrawSurplusInstruction,
  type ParsedProtocolWithdrawSurplusInstruction,
  type ParsedSwapInstruction,
} from '../instructions';

export const VIRTUAL_CURVE_PROGRAM_ADDRESS =
  'virwvN4ee9tWmGoT37FdxZMmxH54m64sYzPpBvXA3ZV' as Address<'virwvN4ee9tWmGoT37FdxZMmxH54m64sYzPpBvXA3ZV'>;

export enum VirtualCurveAccount {
  ClaimFeeOperator,
  Config,
  LockEscrow,
  MeteoraDammMigrationMetadata,
  PoolConfig,
  VirtualPool,
}

export function identifyVirtualCurveAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): VirtualCurveAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([166, 48, 134, 86, 34, 200, 188, 150])
      ),
      0
    )
  ) {
    return VirtualCurveAccount.ClaimFeeOperator;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([155, 12, 170, 224, 30, 250, 204, 130])
      ),
      0
    )
  ) {
    return VirtualCurveAccount.Config;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([190, 106, 121, 6, 200, 182, 21, 75])
      ),
      0
    )
  ) {
    return VirtualCurveAccount.LockEscrow;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([17, 155, 141, 215, 207, 4, 133, 156])
      ),
      0
    )
  ) {
    return VirtualCurveAccount.MeteoraDammMigrationMetadata;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([26, 108, 14, 123, 116, 230, 129, 43])
      ),
      0
    )
  ) {
    return VirtualCurveAccount.PoolConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([213, 224, 5, 209, 98, 69, 119, 92])
      ),
      0
    )
  ) {
    return VirtualCurveAccount.VirtualPool;
  }
  throw new Error(
    'The provided account could not be identified as a virtualCurve account.'
  );
}

export enum VirtualCurveInstruction {
  ClaimProtocolFee,
  ClaimTradingFee,
  CloseClaimFeeOperator,
  CreateClaimFeeOperator,
  CreateConfig,
  InitializeVirtualPoolWithSplToken,
  InitializeVirtualPoolWithToken2022,
  MigrateMeteoraDamm,
  MigrateMeteoraDammLockLpTokenForCreator,
  MigrateMeteoraDammLockLpTokenForPartner,
  MigrationMeteoraDammCreateMetadata,
  PartnerWithdrawSurplus,
  ProtocolWithdrawSurplus,
  Swap,
}

export function identifyVirtualCurveInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): VirtualCurveInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([165, 228, 133, 48, 99, 249, 255, 33])
      ),
      0
    )
  ) {
    return VirtualCurveInstruction.ClaimProtocolFee;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([8, 236, 89, 49, 152, 125, 177, 81])
      ),
      0
    )
  ) {
    return VirtualCurveInstruction.ClaimTradingFee;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([38, 134, 82, 216, 95, 124, 17, 99])
      ),
      0
    )
  ) {
    return VirtualCurveInstruction.CloseClaimFeeOperator;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([169, 62, 207, 107, 58, 187, 162, 109])
      ),
      0
    )
  ) {
    return VirtualCurveInstruction.CreateClaimFeeOperator;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([201, 207, 243, 114, 75, 111, 47, 189])
      ),
      0
    )
  ) {
    return VirtualCurveInstruction.CreateConfig;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([140, 85, 215, 176, 102, 54, 104, 79])
      ),
      0
    )
  ) {
    return VirtualCurveInstruction.InitializeVirtualPoolWithSplToken;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([169, 118, 51, 78, 145, 110, 220, 155])
      ),
      0
    )
  ) {
    return VirtualCurveInstruction.InitializeVirtualPoolWithToken2022;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([27, 1, 48, 22, 180, 63, 118, 217])
      ),
      0
    )
  ) {
    return VirtualCurveInstruction.MigrateMeteoraDamm;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([204, 196, 142, 73, 251, 226, 195, 206])
      ),
      0
    )
  ) {
    return VirtualCurveInstruction.MigrateMeteoraDammLockLpTokenForCreator;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([14, 102, 240, 58, 161, 16, 166, 83])
      ),
      0
    )
  ) {
    return VirtualCurveInstruction.MigrateMeteoraDammLockLpTokenForPartner;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([47, 94, 126, 115, 221, 226, 194, 133])
      ),
      0
    )
  ) {
    return VirtualCurveInstruction.MigrationMeteoraDammCreateMetadata;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([168, 173, 72, 100, 201, 98, 38, 92])
      ),
      0
    )
  ) {
    return VirtualCurveInstruction.PartnerWithdrawSurplus;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([54, 136, 225, 138, 172, 182, 214, 167])
      ),
      0
    )
  ) {
    return VirtualCurveInstruction.ProtocolWithdrawSurplus;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([248, 198, 158, 145, 225, 117, 135, 200])
      ),
      0
    )
  ) {
    return VirtualCurveInstruction.Swap;
  }
  throw new Error(
    'The provided instruction could not be identified as a virtualCurve instruction.'
  );
}

export type ParsedVirtualCurveInstruction<
  TProgram extends string = 'virwvN4ee9tWmGoT37FdxZMmxH54m64sYzPpBvXA3ZV',
> =
  | ({
      instructionType: VirtualCurveInstruction.ClaimProtocolFee;
    } & ParsedClaimProtocolFeeInstruction<TProgram>)
  | ({
      instructionType: VirtualCurveInstruction.ClaimTradingFee;
    } & ParsedClaimTradingFeeInstruction<TProgram>)
  | ({
      instructionType: VirtualCurveInstruction.CloseClaimFeeOperator;
    } & ParsedCloseClaimFeeOperatorInstruction<TProgram>)
  | ({
      instructionType: VirtualCurveInstruction.CreateClaimFeeOperator;
    } & ParsedCreateClaimFeeOperatorInstruction<TProgram>)
  | ({
      instructionType: VirtualCurveInstruction.CreateConfig;
    } & ParsedCreateConfigInstruction<TProgram>)
  | ({
      instructionType: VirtualCurveInstruction.InitializeVirtualPoolWithSplToken;
    } & ParsedInitializeVirtualPoolWithSplTokenInstruction<TProgram>)
  | ({
      instructionType: VirtualCurveInstruction.InitializeVirtualPoolWithToken2022;
    } & ParsedInitializeVirtualPoolWithToken2022Instruction<TProgram>)
  | ({
      instructionType: VirtualCurveInstruction.MigrateMeteoraDamm;
    } & ParsedMigrateMeteoraDammInstruction<TProgram>)
  | ({
      instructionType: VirtualCurveInstruction.MigrateMeteoraDammLockLpTokenForCreator;
    } & ParsedMigrateMeteoraDammLockLpTokenForCreatorInstruction<TProgram>)
  | ({
      instructionType: VirtualCurveInstruction.MigrateMeteoraDammLockLpTokenForPartner;
    } & ParsedMigrateMeteoraDammLockLpTokenForPartnerInstruction<TProgram>)
  | ({
      instructionType: VirtualCurveInstruction.MigrationMeteoraDammCreateMetadata;
    } & ParsedMigrationMeteoraDammCreateMetadataInstruction<TProgram>)
  | ({
      instructionType: VirtualCurveInstruction.PartnerWithdrawSurplus;
    } & ParsedPartnerWithdrawSurplusInstruction<TProgram>)
  | ({
      instructionType: VirtualCurveInstruction.ProtocolWithdrawSurplus;
    } & ParsedProtocolWithdrawSurplusInstruction<TProgram>)
  | ({
      instructionType: VirtualCurveInstruction.Swap;
    } & ParsedSwapInstruction<TProgram>);
